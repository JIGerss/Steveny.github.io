[{"title":"Java Web学习笔记","url":"/2023/05/31/Java-Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"MySQL\n插入数据至表\n\nInsert into stu values\n\n\n更新数据至表\n\nupdate stu set sex =&#x27;nv&#x27; where\n\n\n删除数据\n\ndelete from stu where\n\n\n为表添加外键\n\nalter table stu Constraint fk_emp_dept foreign_key(_id) reference dept(id)\n\n\n多表查询（内连接）\n\nselect * from stu , class where stu.class_id = class.id\n\n\n多表查询（子查询）\n\nselect * from stu where class_id in (select id from class where grade = 3 or grade = 4)\t\n\n​\t\t  \nselect * from (select * from stu where id &gt; 10) where class = 3\n\n\n事务：\n\n开启事务\n\nBEGIN;\t\n\n\n提交事务\n\nCOMMIT;\n\n\n提交事务\n\nROLLBACK;\t\n\n\n​\t升序：ASC\t降序：DESC\n\n\n\nJDBC操作SQLString url = &quot;jdbc:mysql//localhost:3306/database?useSSL=false&quot;;Connection conn = DriverManager.getConnection(url ,account, password);PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1, &quot;str&quot;);ResultSet rs = pstmt.executeQuery();//关闭资源re.close();pstmt.close();conn.close();\n\n\n\nDruid连接池Properties prop = new Properties();prop.load(new FileInputStream(&quot;src/druid.properties&quot;));DataSource dataSource = DruidDataSource.getConnection();......\n\n\n\nMybatis\nhttps://mybatis.net.cn/getting-started.html\n1.定义POJO类2.加载核心配置文件，获取SqlSessionFactory对象3.获取SqlSession对象，执行SQL语句4.释放资源\n\nResultMap映射不同字段名&lt;resultMap id=&quot;userResultMap&quot; type=&quot;user&quot;&gt;        &lt;result column=&quot;psw&quot; property=&quot;password&quot; /&gt;&lt;/resultMap&gt;\n\n\n参数：parameterType&#x3D;”int”\t\t&#x2F;&#x2F;一般省略\n转义字符：\n1.CDATA[]\n2.转义字符 eg.&lt;\n\n传递参数的三种方法1. 加Param注解selectByCondition(@Param(&quot;name&quot;) String name, @Param(&quot;password&quot;) String password, @Param(&quot;uuid&quot;) String uuid);\n\n2. 包装为对象selectByCondition1(User user);\n\n3. 构造集合Map map = new HashMap();\tmap.put(&quot;name&quot;,&quot;name&quot;);\tmap.put(&quot;password&quot;,&quot;password&quot;);\tmap.put(&quot;uuid&quot;,&quot;uuid&quot;);\tselectByCondition2(Map map);\n\n\n\n动态SQL1. 条件语句select *from where1 = 1\t//防止语法问题需在最前面加上恒等式&lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;\tand name = #&#123;name&#125;&lt;/if&gt;&lt;if test=&quot;password != null and password !=&#x27;&#x27;&quot;&gt;\tand name = #&#123;name&#125;&lt;/if&gt;\n\n\n\n2. 动态where语句select *from&lt;where&gt;\t&lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;\t\tand name = #&#123;name&#125;\t&lt;/if&gt;\t&lt;if test=&quot;password != null and password !=&#x27;&#x27;&quot;&gt;\t\tand name = #&#123;name&#125;\t&lt;/if&gt;&lt;/where&gt;\n\n\n\n3. 单条件查询：select * from where&lt;choose&gt;\t&lt;when test=&quot;name != null&quot;&gt;\t\tname = #&#123;name&#125;\t&lt;/when&gt;\t&lt;when test=&quot;password != null&quot;&gt;\t\tpassword = #&#123;password&#125;\t&lt;/when&gt;\t&lt;otherwise&gt;\t\t1 = 1\t&lt;/otherwise&gt;&lt;/choose&gt;\n\n\n\n4. 添加-主键返回&lt;insert id=&quot;addUser&quot; useGeneratedKey=&quot;true&quot; keyProperty=&quot;uuid&quot;&gt;\tinsert into users(name, psw) values(#&#123;name&#125;,#&#123;password&#125;);&lt;/insert&gt;\n\n\n\n5. 修改语句（动态set语句）&lt;update id=&quot;updateUser&quot;&gt;\tupdate users\t&lt;set&gt;\t\t&lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;\t\t\tname = #&#123;name&#125;,\t\t&lt;/if&gt;\t\t&lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;\t\t\tname = #&#123;password&#125;\t\t&lt;/if&gt;\t&lt;/set&gt;\twhere uuid = #&#123;uuid&#125;;&lt;/update&gt;\n\n​\t\t\n6. 批量删除（foreach遍历语句）\n接口：void deleteUser(@Param(&quot;ids&quot;) int[] ids);\n\n&lt;delete id=&quot;deleteUser&quot;&gt;\tdetele from users\twhere id in\t&lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;\t\t#&#123;id&#125;\t&lt;/foreach&gt;&lt;/delete&gt;\n\n\n\nHttpServlet1. 控制response输出类型response.setContentType(&quot;text/html;charset=utf-8&quot;);\n\n2. request转发request.getRequestDispatcher(&quot;资源b的虚拟路径&quot;).forward(request, response);\n\n3. response重定向response.sendRedirect(&quot;资源b的虚拟路径&quot;);\n\n4. request添加键值对request.setAttribute(&quot;users&quot;, users);\n\n\n\n会话技术1. Cookie设置Cookie cookie = new Cookie(&quot;username&quot;, &quot;Steveny&quot;);response.addCookie(cookie);\n\n2. Cookie获取Cookie[] cookies = request.getCookie();for(Cookie c:cookies)&#123;\tString name = c.getName();\t\tif(&quot;username&quot;.equals(name))&#123;\t\tString value = c.getValue();\t&#125;&#125;\n\n3. 设置存活时间（单位：秒）cookie.setMaxAge(60*60*24*7);\n\n4. Cookie无法存中文的问题URLencoder.encode(&quot;str&quot;, &quot;UTF-8&quot;);URLdecoder.decode(&quot;str&quot;, &quot;UTF-8&quot;);\n\n\n\nVue框架1. 创建vue对象并绑定数据模型\n    new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                username = \"\";\n                addrs = [\"a\",\"b\",\"c\"]\n            }\n        }\n    })\n\n\n2. 常用指令\nv-model&#x3D;”username”：绑定数据模型\n\nv-bind:href&#x3D;”url”：绑定属性（可以省略v-bind）\n\nv-on:click&#x3D;”show()”：绑定事件（方法）可以简化为@clickmethods:{    show(){        alert(“Click!!!”);    }}\n\nv-if&#x2F;v-else&#x2F;v-else-if&#x3D;”count &#x3D;&#x3D; 2”：条件语句（html文件里不会显示其他分支内容）\n\nv-show&#x3D;”count &#x3D;&#x3D; 3”：根据条件是否显示组件（html文件里会显示其他分支内容）\n\nv-for&#x3D;”addr in addrs”：遍历，addr为索引\n\nmounted()：钩子，表示挂载完成\n\n\n"},{"title":"Java多线程","url":"/2023/05/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"1. 开启线程的三种方式继承Thread类\n继承Thread类并重写他的run方法\n\nclass testThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程开启&quot;);    &#125;&#125;class StudyApplicationTests &#123;    public static void main(String[] args) &#123;        Thread t = new testThread();        t.start();\t\t\t// 不能直接用run，不然依然是同步运行    &#125;&#125;\n\n实现Runnable接口\n实现Runnable接口并实现run方法\n\nclass testRunnable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程开启&quot;);    &#125;&#125;class StudyApplicationTests &#123;    public static void main(String[] args) &#123;        new Thread(new testRunnable()).start();\t\t// 可以使用Lambda表达式    &#125;&#125;\n\n实现Callable&lt;T&gt;接口class testCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        System.out.println(&quot;线程开启&quot;);        return 100;    &#125;&#125;class StudyApplicationTests &#123;    public static void main(String[] args) &#123;        testCallable testCallable = new testCallable();        ExecutorService threadPool = Executors.newFixedThreadPool(10);\t\t// 生成固定大小线程池        Future&lt;Integer&gt; future = threadPool.submit(testCallable);\t\t\t// 提交完即执行        try &#123;            Integer integer = future.get();\t\t\t\t\t\t\t\t\t// 获取结果，可设置超时时间            System.out.println(integer);        &#125; catch (InterruptedException | ExecutionException e) &#123;\t\t\t\t// 线程终止异常            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n2. 同步方法和同步块\n将一个方法上加上synchronized关键字即可将方法声明为同步方法\n\n同步方法会为当前方法所在对象加锁，即this。不能将一个大方法声明为synchronized，会影响效率\n\n同步块可以在括号中加入要加锁的对象来局部加锁。\nsynchronized(obj) &#123;\t...&#125;\n\n线程安全的集合\n数组：CopyOnWriteArrayList&lt;T&gt;\nMap：ConcurrentHashMap\n\n锁\n死锁：多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源。（如果一个同步块中同时持有两个以上对象的锁，就可能发生死锁的问题）\nsynchronized (obj1) &#123;    System.out.println(&quot;拿到锁1&quot;);    synchronized (obj2) &#123;    \tSystem.out.println(&quot;拿到锁2&quot;);\t&#125;\t&#125;\n\n显式加锁：\nReentrantLock lock = new ReentrantLock();try &#123;    lock.lock();    System.out.println(&quot;加锁喽&quot;);&#125; finally &#123;    lock.unlock();&#125;\n\n生产者消费者问题\nJava中线程通知的方法（需要在同步方法或同步块中使用，否则会抛异常）\n\n\n\n\n方法名\n作用\n\n\n\nwait()\n表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁\n\n\nwait(long timeout)\n指定等待的毫秒数\n\n\nnotify()\n唤醒一个处于等待状态的线程\n\n\nnotifyAll()\n唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度\n\n\n\n缓冲区法：\nclass Container &#123;    Product[] products = new Product[10];    int count;        public synchronized Product pop() throws InterruptedException &#123;        if (count == 0) &#123;            this.wait();\t\t// 等待生产者生产（释放锁）        &#125;        count--;        this.notifyAll();\t\t// 通知生产者生产        return products[count];    &#125;\t    public synchronized void push(Product product) throws InterruptedException &#123;        if (count == products.length) &#123;            this.wait();\t\t// 等待消费者消费（释放锁）        &#125;        products[count] = product;        count++;        this.notifyAll();\t\t// 通知消费者消费    &#125;&#125;\n\n\n\n信号灯法：\nclass TV &#123;    String show;    boolean flag;\t\t// true代表节目准备就绪可以观看\tfalse代表节目未准备就绪不能观看    public synchronized void changeShow(String show) throws InterruptedException &#123;        if (flag) &#123;            this.wait();        &#125;        this.show = show;        this.flag = true;        System.out.println(&quot;正在播放：&quot; + show);        this.notifyAll();    &#125;    public synchronized String getShow() throws InterruptedException &#123;        if (!flag) &#123;            this.wait();        &#125;        System.out.println(&quot;正在看：&quot; + this.show);        this.flag = false;        this.notifyAll();        return this.show;    &#125;&#125;\n\n3. 线程池\n\n开启线程池：\nExecutorService service = Executors.newFixedThreadPool(10);\t\t// 固定大小线程池FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; 100);service.execute(() -&gt; System.out.println(&quot;线程开启&quot;));service.submit(() -&gt; System.out.println(&quot;线程开启&quot;));service.submit(futureTask);service.shutdown();\n\n"},{"title":"MybatisPlus","url":"/2023/05/31/MybatisPlus/","content":"标准数据层开发和分页\nMybatisPlus（以下简称MP）是基于Mybatis框架基础上开发的增强型工具，旨在简化开发、提高效率\n\n快速入门：\n\n添加mybatis-plus-boot-starter起步依赖\n让原来的Dao数据层接口继承BaseMapper并给出数据泛型即可\n\n\n如果修改操作导入的实体类对象含有空值，则不修改该值\n\n小工具Lombok，可以快速封装实体类\n\n分页操作：\n\n创建IPage接口对象并使用Page实体类初始化，传入页码和每页的数据数\n\nIPage page = new Page(1, 5);\npage.getSize();\t\t//每页显示数\npage.getCurrent();\t//当前页码值\npage.getTotal();\t//总共多少条数据\npage.getRecords();\t//数据\n- 创建Mybatis拦截器的Bean并导入分页拦截器  - ```Java    @Configuration    public class MpConfig &#123;            @Bean        public MybatisPlusInterceptor mpInterceptor()&#123;            MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();            mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());            return mpInterceptor;        &#125;    &#125;\n\n\n\n\n\n\n\n\n如果需要查看MP执行时的sql语句，可以在application配置中打开MP的日志\n\n条件查询\n步骤\n\n使用QueryWrapper设定查询条件\n QueryWrapper qw = new QueryWrapper();qw.lt(&quot;id&quot;, 2);List list = userDao.selectList(qw);System.out.println(list);\n\n使用Lambda表达式设定查询条件\n QueryWrapper&lt;User&gt; qw = new QueryWrapper&lt;User&gt;();qw.lambda().lt(User::getId, 2);List&lt;User&gt; list = userDao.selectList(qw);System.out.println(list);\n\n使用带Lambda的QueryWrapper设定查询条件（Recommended）\n LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();qw.lt(User::getId, 2);List&lt;User&gt; list = userDao.selectList(qw);System.out.println(list);\n\n\n更多条件举例\n\nid大于1小于3：\n  qw.gt(User::getId, 2).lt(User::getId, 3);\n\nid大于30或小于10：\n  qw.lt(User::getId, 10).or().gt(User::getId, 30);\t//注意加or()\n\nid等于1\nqw.eq(User::getId, 1);\n\nid大于等于1\nqw.ge(User::getId, 1);\n\n模糊查询\nqw.like(User::getUsername, &quot;Ste&quot;);\t\t//含有Ste的qw.likeRight(User::getUsername, &quot;Ste&quot;);\t//以Ste开头的qw.likeLeft(User::getUsername, &quot;Ste&quot;);\t//以Ste结尾的\n\n\n处理null的数据\nInteger id = null;LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();qw.lt(null != id, User::getId, 3);\t\t//加入condition参数\n\n\n\n查询投影\n\n可以用来设置查询字段\nqw.select(User::getId, User::getUsername);\t//查询结果显示其id和usernameList&lt;User&gt; list = userDao.selectList(qw);\n\n可以用来查询数量\nQueryWrapper&lt;User&gt; qw = new QueryWrapper&lt;&gt;();qw.select(&quot;count(*)&quot;);List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(qw);System.out.println(list);\n\n可以用来分组\nQueryWrapper&lt;User&gt; qw = new QueryWrapper&lt;&gt;();qw.select(&quot;count(*)&quot;);qw.groupBy(&quot;username&quot;);List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(qw);System.out.println(list);\n\n\n\n映射匹配兼容性\n字段不一致\npublic class User &#123;    private Long id;    private String username;    @TableField(value = &quot;psw&quot;)    private String password;&#125;\n\n排除属性\npublic class User &#123;    private Long id;    private String username;    private String password;    @TableField(exist = false)    private Integer online;&#125;\n\n不参与查询\npublic class User &#123;    private Long id;    private String username;    @TableField(select = false)    private String password;&#125;\n\n表名不一致\n@TableName(&quot;tbl_user&quot;)public class User &#123;    private Long id;    private String username;    private String password;&#125;\n\nDML编程控制\nId生成策略\npublic class User &#123;\t@TableId(type = IdType.ASSIGN_ID)\t//雪花算法生成ID    private Long id;    private String username;    private String password;&#125;\n\n\n可以在配置中的id-type中设置全局ID生成策略\n\n\n多数据操作\nList&lt;Long&gt; list = new List&lt;&gt;();list.add(1L);list.add(2L);//...userDao.selectBatchIds(list);\n\n逻辑删除\n\n作用：在数据库中加一个被删除的标记，保留原数据但无法被MP查询\n\n方法：\npublic class User &#123;    private Long id;    private String username;    private String password;    @TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;)\t//1代表已经被删除，0代表没有被删除\tprivate Integer deleted;&#125;\n\n\n可以在配置中加入logic-delete-field，logic-not-delete-value，logic-delete-value来配置全局逻辑删除\n\n\n\n\n\n乐观锁\n原理：在表中加入version字段来限制同时修改的操作数量\nupdate user set password = &quot;实际修改&quot;, version = version + 1 where version = #原来的version值\n\n方法：\n\n在数据表和实体类中加入version字段\npublic class User &#123;    private Long id;    private String username;    private String password;    @Version\t\t\t\t\t\t//必要    private Integer version;&#125;\n\n添加MP拦截器 OptimisticLockerInnerInterceptor\n\n执行查询操作时给出version值（一般为查询的数据）\n\n\n\n\n代码生成器\n模板：MP提供\n数据库相关配置（如字段名）：从数据库中读取\n开发者自定义配置：手工配置\n\n"},{"title":"Spring Framework","url":"/2023/05/31/Spring-Framework/","content":"1. 使用配置文件配置beans基础步骤\n导入spring坐标\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;x.x.x.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n创建applicationContext.xml配置文件\n在文件中添加beans\n\n装载数据的几种方式方式一：构造器注入&lt;bean id=&quot;userService&quot; class=&quot;com.steveny.service.impl.UserServiceImpl&quot;/&gt;\n\n方式二：静态工厂注入&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.steveny.utils.SqlSessionFactoryUtil&quot; factory-method=&quot;getSqlSessionFactory&quot;/&gt;\n\n方式三：FactoryBean注入\n工厂配置\n\npublic class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; &#123;    //获取对象\tpublic UserDao getObject() &#123;\t\t\treturn new UserDao();\t&#125;        //指定对象类型    public Class&lt;?&gt; getObjectType()&#123;        return UserDao.class;    &#125;&#125;\n\n\nbean配置\n\n&lt;bean id=&quot;userService&quot; class=&quot;com.steveny.factory.UserDaoFactoryBean&quot;/&gt;\n\n方式四：setter注入&lt;bean id=&quot;userService&quot; class=&quot;com.steveny.service.impl.UserServiceImpl&quot;&gt;\t&lt;property name=&quot;参数名&quot; ref=&quot;引用&quot;/&gt;    &lt;property name=&quot;参数名&quot; value=&quot;值&quot;/&gt;&lt;/bean&gt;\n\n方式五：自动装配&lt;bean id=&quot;userService&quot; class=&quot;com.steveny.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;/&gt;\n\n方式六：集合注入&lt;bean id=&quot;userService&quot; class=&quot;com.steveny.service.impl.UserServiceImpl&quot;&gt;\t&lt;property name=&quot;数组变量名&quot;&gt;    \t&lt;array&gt;        \t&lt;value&gt;100&lt;/value&gt;            &lt;value&gt;200&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;        &lt;property name=&quot;列表变量名&quot;&gt;    \t&lt;list&gt;        \t&lt;value&gt;100&lt;/value&gt;            &lt;value&gt;200&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;        &lt;property name=&quot;map变量名&quot;&gt;    \t&lt;map&gt;        \t&lt;entry key=&quot;a&quot; value=&quot;1&quot;/&gt;            &lt;entry key=&quot;b&quot; value=&quot;2&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;        &lt;property name=&quot;prop变量名&quot;&gt;    \t&lt;props&gt;        \t&lt;prop key=&quot;a&quot;&gt;1&lt;/prop&gt;            &lt;prop key=&quot;b&quot;&gt;2&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n加载properties文件\n修改配置文件\n\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;              xsi:schemaLocation=&quot;            http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd            &quot;&gt;&lt;/beans&gt;\n\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       ---&gt;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\t\t\t//1       xsi:schemaLocation=&quot;            http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd                           ---&gt;        http://www.springframework.org/schema/context \t\t\t\t\t\t//2---&gt;        http://www.springframework.org/schema/context/spring-context.xsd\t//3            &quot;&gt;&lt;/beans&gt;\n\n\n导入命名空间\n\n&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;\n\n\n引用变量\n\n$&#123;jdbc.name&#125;\n\n\n\n导入当前目录下的所有properties文件\n&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt;\n\n不使用系统property\n&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;\n\n\n2. 容器加载配置文件方式一：加载类路径下的配置文件ApplicationContext alc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n\n方式二：加载绝对路径下的配置文件ApplicationContext alc = new FileSystemXmlApplicationContext(&quot;C:\\\\Users\\\\16649\\\\IdeaProjects\\\\Poker\\\\Poker_Controller\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;)\n\n获取beanUserService userService1 = (UserService) alc.getbean(&quot;UserService&quot;);\t\t\t//按名称UserService userService2 = alc.getbean(&quot;UserService&quot;, UserService.class);\t\t//按名称并转换类型UserService userService3 = alc.getbean(UserService.class);\t\t\t\t\t\t//按类型\n\nbean配置总结\n3. 注解开发注解创建bean方式一：使用@Component\n还可以使用@Controller\t@Service\t@Repository\n\n在配置文件中加入\t&#96;\n&lt;context:component-scan base-package=&quot;com.steveny&quot;/&gt;`\n\n方式二：使用配置类创建配置类\n@Configuration@ComponentScan(&quot;com.steveny&quot;)public class SpringConfig()&#123;&#125;\n\n创建容器\nApplicationContext alc = new AnnotationConfigApplicationContext(SpringConfig.class);\n\n\n注意\n当需要配置多个扫描路径时，需要使用数组的形式\n\n@Configuration@ComponentScan(&#123;&quot;com.steveny.service&quot;,&quot;com.steveny.web&quot;&#125;)public class SpringConfig()&#123;&#125;\n\n注解依赖注入自动装配@AutoWired@Qualifier(&quot;userService&quot;)\t\t\t//引用装配(可以不写，用来区分同类型的其他bean)\n\n注意：1. 默认是按照类型注入，需保证本类型无其他bean\n​\t\t\t2. 采用暴力反射方式注入\n一般类型注入\n内部注入\n\n@Value(&quot;franky&quot;)public String username;\n\n\n从外部properties文件注入\n\n​\t\t（1）在SpringConfig类中加上@PropertySource注解\n@Configuration\t\t@PropertySource(&quot;properties文件&quot;)public class SpringConfig()&#123;&#125;\n\n​\t\t（2）在@Value注解中加入${}\n@Value(&quot;$&#123;username&#125;&quot;)\n\n注意：多个properties文件不支持通配符*加载，只能使用数组来表示\n注解管理第三方bean创建第三方bean\n创建对应Config类，手动实现方法，最后加上@Bean注解\n\npublic class JdbcConfig &#123;    private static final SqlSessionFactory sqlSessionFactory;    static &#123;        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = null;        try &#123;            inputStream = Resources.getResourceAsStream(resource);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    &#125;    @Bean    public SqlSessionFactory getSqlSessionFactory() &#123;        return sqlSessionFactory;    &#125;&#125;\n\n\n在SpringConfig类加上@Import注解\n\n@Configuration@Import(&#123;JdbcConfig.class&#125;)\t\t\t//数组public class SpringConfig()&#123;&#125;\n\n\n\n\n\n为第三方资源注入资源\n一般类型\n\n@Value(&quot;root&quot;)//@Value(&quot;$&#123;username&#125;&quot;)private String username;\n\n\n引用类型\n\n在@bean所注释的方法中添加对应参数\nspring会自动装配对应依赖\n@Beanpublic SqlSessionFactory getSqlSessionFactory(UserService userService)&#123;&#125;\n\n\n\nSpring整合Mybatis\n导入spring-jdbc和mybatis-spring的坐标\n\n创建Config类，并使用SqlSessionFactoryBean快速创建对象\n\n使用@Bean添加第三方bean，并在参数中加上Druid的DataSource对象\n\n创建MapperScannerConfigurer bean\n\n\npublic class MybatisConfig &#123;    @Bean    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();        factoryBean.setTypeAliasesPackage(&quot;com.steveny.pojo&quot;);        factoryBean.setDataSource(dataSource);        return factoryBean;    &#125;        @Bean    public MapperScannerConfigurer mapperScannerConfigurer()&#123;        MapperScannerConfigurer msc = new MapperScannerConfigurer();        msc.setBasePackage(&quot;com.steveny.mapper&quot;);        return msc;    &#125;&#125;\n\n\n在Service层中加上@AutoWired注解，Spring会自动装配\n\nSpring整合JUnit\n导入junit和spring-test的坐标\n使用Spring整合Junit专用的类加载器\n\n//设置类运行器@RunWith(SpringJUnit4ClassRunner.class)//设置Spring环境对应的配置类@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest &#123;    //支持自动装配注入bean    @Autowired    private AccountService accountService;    @Test    public void testFindById()&#123;        System.out.println(accountService.findById(1));    &#125;&#125;\n\n4. AOP面向切面编程\nAOP为Aspect Oriented Programming的缩写\nSpring主张的非侵入式编程\n在不惊动源代码的情况下添加功能\n\n\n基础步骤\n导入spring-aop（spring-context自带）和aspectjweaver的坐标\n创建通知类\n在通知类中创建通知方法和代理方法，并用@PointCut注解描述切入点的方法\n在通知类上加入@Component和@Aspect注解\n在SpringConfig类上加入@EnableAspectJAutoProxy\n\n//通知类必须配置成Spring管理的bean@Component//设置当前类为切面类类@Aspectpublic class MyAdvice &#123;    //设置切入点，要求配置在方法上方    @Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)    private void pt()&#123;&#125;    //设置在切入点pt()的前面运行当前操作（前置通知）    @Before(&quot;pt()&quot;)    public void method()&#123;        System.out.println(System.currentTimeMillis());    &#125;&#125;\n\n通知类型\n前置通知@Before(“pt()”)\n后置通知@After(“pt()”)\n环绕通知@Around(“pt()”)\n\n​\t\t在通知方法的第一个参数加上ProceedingJoinPoint，并在需要环绕的地方加入pjp.proceed();\n​\t\t通过返回Object的方法获取原方法中的返回值\n@Around(&quot;pt()&quot;)public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;    System.out.println(&quot;around before advice ...&quot;);    //表示对原始操作的调用    Object ret = pjp.proceed();    System.out.println(&quot;around after advice ...&quot;);    return ret;&#125;\n\n\n返回后通知@AfterReturning\n抛出异常后通知@AfterThrowing\n\n如果需要获取所切入的具体方法的信息，则可以使用ProceedingJoinPoint类中的getSignature()方法\nSignature sg = pjp.getSignature();System.out.println(sg.getDeclaringTypeName());\t\t//切入点所在类的名称System.out.println(sg.getName())；\t\t\t\t\t//切入的方法名\n\nAOP通知获取参数和返回值\n在@Before和@After方法中使用JoinPoint参数中的getArgs()方法获取参数\n\n在@AfterReturning方法中使用Object参数接受返回值，并在@AfterReturning注解中加入returning &#x3D; “ret”（ret为对应参数名）\n\n\nSpring事务\n特点：\n\n原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做要么全不做\n一致性：数据不会因为事务的执行而遭到破坏\n隔离性：一个事务的执行，不受其他事务的干扰，即并发执行的事务之间互不干扰\n持久性：一个事务一旦提交，它对数据库的改变就是永久的。\n\n\n注意事项：\n\n调用子方法时如果父方法声明了@Transactional，则不会移交事务控制权\n\n使用try-catch处理异常后，则事务将不会处理，需要为@Transactional添加rollBackFor属性\n@Transactional(rollbackFor = &#123;DataIntegrityViolationException.class, FailToJoinGameException.class&#125;)\n\n\n\n基本使用控制一系列业务层或数据层的事务共成功共回滚的方法\n\n在JdbcConfig中加入TransactionManager的Bean\n\n@Beanpublic TransactionManager transactionManager(DataSource dataSource)&#123;    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();    transactionManager.setDataSource(dataSource);    return transactionManager;&#125;\n\n\n在SpringConfig中加入@EnableTransactionManagement注解\n在需要开启事务的方法上加入@Transactional注解\n\n控制事务传播行为背景：某些操作无需参与Spring的共成功共失败的事务，需要单独创建一个事务\n举例：无论转账操作成功与否，都在数据库中加入日志信息\n方法：在@Transactional注解中加入\nPropagation = Propagation.REQUIRES_NEW\n\n\n5.SpringMVC技术基本使用\n导入spring-webmvc的坐标\n创建SpringMVC控制器类（等同于Servlet功能）\n\n@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/login&quot;)\t//设置映射路径    @ResponseBody\t\t\t\t//设置方法返回值作为响应数据    public String login()&#123;        return &quot;&#123;&#x27;info&#x27;:&#x27;Success&#x27;&#125;&quot;;    &#125;&#125;\n\n\n创建SpringMvcConfig类，加载对应的Bean\n初始化SpringMVC容器，使用AnnotationConfigWebApplicationContext对象并注册对应config类来创建Spring容器\n\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;    @Override    protected WebApplicationContext createServletApplicationContext() &#123;        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();        ctx.register(SpringMvcConfig.class);        return ctx;    &#125;    @Override    protected WebApplicationContext createRootApplicationContext() &#123;        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();        ctx.register(SpringConfig.class);        return ctx;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;/&quot;&#125;;    &#125;&#125;\n\n\n\n过滤SpringConfig扫描规则加入excludeFilter参数\n@Configuration@ComponentScan(value = &quot;com.steveny&quot;,        excludeFilters = @ComponentScan.Filter(                type = FilterType.ANNOTATION,                classes = Controller.class        ))@Import(&#123;JdbcConfig.class, MybatisConfig.class&#125;)public class SpringConfig &#123;&#125;\n\n\n\n简化SpringMVC容器通过导入SpringConfig和SpringMVCConfig类来创建容器\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[]&#123;SpringConfig.class&#125;;    &#125;    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123;SpringMvcConfig.class&#125;;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;/&quot;&#125;;    &#125;&#125;\n\n\n\n映射路径的细节\n如果多个类同时访问一个路径，则会报错\n\n解决：在访问路径前加上模块名，并在模块类上加入@RequestMapping注解\n@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/login&quot;)\t//设置映射路径    @ResponseBody\t\t\t\t//设置方法返回值作为响应数据    public String login()&#123;        return &quot;&#123;&#x27;info&#x27;:&#x27;Success&#x27;&#125;&quot;;    &#125;&#125;\n\n\n\n处理post请求的中文乱码解决：在SpringMVC容器中添加过滤器\n@Overrideprotected Filter[] getServletFilters() &#123;    CharacterEncodingFilter filter = new CharacterEncodingFilter();    filter.setEncoding(&quot;UTF-8&quot;);    return new Filter[]&#123;filter&#125;;&#125;\n\n\n\n参数传递特殊类型的传递（接收）\n传入参数与接收实参名称不一样\n\n​\t使用@RequestParam(&quot;传入参数名&quot;)注解与实参前\n... method(@RequestParam(&quot;name&quot;) String username)\n\n\n传入POJO参数\n\n​\t如果该类型中属性名称与传入参数名称一样，则SpringMVC将自动装配\npublic String login(User user)&#123;        return null;&#125;\n\n\n传入带引用的POJO\n\n​\t则需要传入参数名称加上引用参数的名称，Spring会自动装配\n/*name = Stevenypsw = 123address.id = 123address.name = franky*/class User&#123;\tString name;\tint psw;\t\tAddress address;&#125;class Address&#123;\tString name;\tint id;&#125;\n\n\n传入数组\n\n​\t只需要传入多个同一名称的参数即可\n/*likes = 1likes = 2likes = 3likes = 4*/public String getLikes(int[] likes)&#123;    return null;&#125;\n\n\n传入集合数据\n\n​\t问题：如果直接使用传入数组的方式Spring会报错，因为Spring尝试将List视为POJO对象去使用其构造方法，但List接口无构造方法\n​\t解决：使用@RequestParam注解告诉Spring只去接收数据而不是创建对象\npublic String login(@RequestParam()List&lt;String&gt; user)&#123;        return user;&#125;\n\n\n\nJSON参数的传递\n在SpringMVCConfig上加上@EnableWebMvc注解\n在需要传递参数的地方加上@RequestBody注解\n需要Jackson依赖\n\n日期参数传递\n在Date参数前加上@DateTimeFormat注解（形参注解）\n为pattern变量赋值，写上日期格式。eg：yyyy-MM-dd HH:mm:ss\n\n响应返回页面方法：直接在返回字符串中写上对应页面文件名称，并删去@ResponseBody注解\n@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/loginPage&quot;)    public String loginPage()&#123;        return &quot;login.html&quot;;    &#125;&#125;\n\n\n\n响应文本和POJO数据方法：返回pojo数据并返回值填上该类型\n注意：需要Jackson依赖\n@RequestMapping(&quot;/loginPage&quot;)@ResponseBodypublic User loginPage()&#123;    return user;&#125;\n\n\n\n总结：@ResponseBody会设置当前控制器返回值作为响应体\nRest风格核心：运用不同的url和请求方法的组合来区分不同的方法，并隐藏路径与操作\n\n\n@RestController注解\n\n​\t\t@RestController整合了@Controller和@ResponseBody注解，简化书写\n\n@GetMapping，@PostMapping，@DeleteMapping注解\n\n​\t\t简化了@RequestMapping(method = RequestMethod.GET)的写法\n\n@PathVariable，@RequestBody注解\n分别从URL路径和请求体中获取变量。前者需要使用&#123;variableName&#125;在URL中表示参数位置\n\n例子：\n\n\n @RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123;    @GetMapping    public String get()&#123;        return &quot;&#123;&#x27;info&#x27;:&#x27;Success&#x27;&#125;&quot;;    &#125;    @GetMapping(&quot;/&#123;name&#125;/&#123;password&#125;&quot;)    public String login(@PathVariable String name, @PathVariable String password)&#123;        return &quot;&#123;&#x27;info&#x27;:&#x27;Success&#x27;&#125;&quot;;    &#125;    @PostMapping    public String register(@RequestBody String name, @RequestBody String password)&#123;        return &quot;&#123;&#x27;info&#x27;:&#x27;Success&#x27;&#125;&quot;;    &#125;    @DeleteMapping(&quot;/&#123;name&#125;/&#123;password&#125;&quot;)    public String delete(@PathVariable String name, @PathVariable String password)&#123;        return &quot;&#123;&#x27;info&#x27;:&#x27;Success&#x27;&#125;&quot;;    &#125;&#125;\n\n\n三种引用变量的方式：\n\n​\t#{}：Mybatis在SQL语句中引用变量\n​\t${}：Spring引用properties变量\n​\t{}：在SpringMVC中表示变量在URL中的位置\n6.SSM整合 \n前后台协议联调\n通常情况下，需要前后端人员协商通信协议来消除不必要的矛盾\n通常定义一个协议类来封装数据\n\n\npublic class Result &#123;    private Object data;\t\t//数据    private Integer status;\t\t//状态码    private String msg;\t\t\t//消息&#125;\n\n\n可以通过创建多个常量的方式来描述状态码\n\npublic class Status &#123;    public static final Integer LOGIN_OK = 10011;    public static final Integer REGISTER_OK = 10021;    public static final Integer LOGIN_ERR = 10010;    public static final Integer REGISTER_ERR = 10020;&#125;\n\n\n\n异常处理器异常处理思路\n异常处理思路：将所有层的所有异常全部抛出，汇集到表现层集中处理，并使用AOP思想对异常分类、统一\n方法：在表现层下创建异常处理器并加载，使用@ExceptionHandler拦截对应异常。\n注意：该方法实际为AOP的@After\n\n@RestControllerAdvicepublic class ProjectExceptionAdvice &#123;    @ExceptionHandler(Exception.class)    public Result doException(Exception exception) &#123;        System.out.println(&quot;ERROR!&quot;);        return new Result(233, &quot;ERROR&quot;);    &#125;&#125;\n\n\n\n项目异常处理\n业务异常（Business Exception）\n\n发送对应消息给用户，提醒规范操作\n\n\n系统异常（System Exception）\n\n发送固定消息给用户，安抚用户\n\n发送特定消息给运维，提醒维护\n\n记录日志\n\n\n\n其他异常（Exception）\n\n\n@RestControllerAdvicepublic class ProjectExceptionAdvice &#123;    //业务异常    @ExceptionHandler(BusinessException.class)    public Result doBusinessException(BusinessException exception) &#123;        return new Result(Status.BUSINESS_ERR, null, &quot;数据格式错误，请重试！&quot;);    &#125;    //系统异常    @ExceptionHandler(SystemException.class)    public Result doSystemException(SystemException exception) &#123;        //记录日志        return new Result(Status.SYSTEM_ERR, null, &quot;服务器错误，请稍后再试！&quot;);    &#125;    //其他异常    @ExceptionHandler(Exception.class)    public Result doException(Exception exception) &#123;        //记录日志        return new Result(Status.UNKNOWN_ERR, null, &quot;系统繁忙，请稍后再试！&quot;);    &#125;&#125;\n\n\n\n拦截器\n一个Http请求在服务器完整过程：\n拦截器是一段在所有controller前必须执行的代码。例如：权限检测\n\n\n\n\n\n拦截器（Interceptor）与过滤器（Filter）的区别：\n\n拦截器属于SpringMVC技术，过滤器属于Servlet技术\n拦截器只能作用与SpringMVC，而过滤器可以作用于整个tomcat\n\n\n步骤：\n\n创建配置类SpringMVCSupport并继承WebMvcConfigurationSupport\n\n @Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;    @Autowired    ProjectInterceptor projectInterceptor;    @Override    protected void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users&quot;);        //registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users&quot;, &quot;/users/*&quot;);    &#125;&#125;\n\n在表现层下创建拦截器类（Interceptor）并实现HandlerInterceptor接口，别忘了加上@Component\n\n @Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123;   //preHandle(), postHandle(), afterCompletion()&#125;\n\n注意事项：\n示例中的拦截器只能拦截 &#x2F;users 这一个路径请求，无法拦截例如 &#x2F;users&#x2F;franky 这种路径，如需拦截 &#x2F;users 下的请求，则需要额外拦截 &#x2F;users&#x2F;* 。\npreHandle() 表示进入拦截器调用的方法，postHandle() 表示离开拦截器调用的方法，afterCompletion() 表示postHandle()方法结束之后调用的方法。\n拦截器的preHandle() 方法的返回值为是否执行后续操作的布尔值，true为放行操作，false为拦截操作。\n\n\n\n\n\n简化开发\n可以将SpringMvcConfig实现WebMvcConfigurer接口将SpringMvcConfig与SpringMvcSupport合并\n\n@Configuration@EnableWebMvc@ComponentScan(&quot;com.steveny.controller&quot;)public class SpringMvcConfig implements WebMvcConfigurer &#123;    @Autowired    ProjectInterceptor projectInterceptor;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);        registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/css/&quot;);        registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/js/&quot;);        registry.addResourceHandler(&quot;/imgs/**&quot;).addResourceLocations(&quot;/imgs/&quot;);    &#125;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/&quot;);    &#125;&#125;\n"},{"title":"SpringBoot入门","url":"/2023/05/31/SpringBoot%E5%85%A5%E9%97%A8/","content":"基本使用\n目的：用来简化Spring原生开发\n优点：简化了Spring原生开发中初步搭建过程和开发过程，且最后不需要额外提供tomcat服务端而是直接运行\n原理：使用起步依赖方法帮助开发者导入若干配置\n基本操作：\n创建boot程序和controller类\n运行Application.class\n\n\n\n\nSpringBoot将tomcat服务端更换成jetty的流程：\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\nSpringBoot配置文件方法：\n① 在resource下的application.properties中配置（优先的配置）\n② 在application.yml中配置（推荐）\n③ 在application.yaml中配置（不推荐因为idea不提示，可以在模块配置的Fecets中加上配置解决）\n\n\n\nyaml格式user: name: franky age: 20 tel: 123456 result: data:  array:   - 1   - 222   - 343333\n\n\n优点：易阅读，重数据，轻格式\n规则：\n大小写敏感\n数据前有一个空格\n不同层级用空格区分\n\n\n\n读取自定义配置\n在boot程序中可以通过：\n\n注入的形式读取配置（如：”${user.name}”，”${result.data.array[0]}”）\n\n使用自动装配的Environment类来自动读取配置\n\n使用类来接收\n\n@Component\n@ConfigurationProperties(prefix = &quot;user&quot;)\npublic class User &#123;\n&#125;\n- **优先级：**  - 最高- jar包外的config文件夹中的配置文件  - 高-     jar包外的配置文件  - 中-     resource中config下的配置文件  - 低-     resource下的配置文件###### 多环境开发1. **使用yml中的profile属性**```yamlspring:  profiles:    active: dev\t\t#使用的环境---#开发spring:  config:    activate:      on-profile: devserver:  port: 8080---#生产spring:  config:    activate:      on-profile: proserver:  port: 8090---\n\n\n\n\n\n\n\n\n使用properties的多文件配置\n\n\napplication.properties——————-&gt;spring.profiles.active&#x3D;pro\n\napplication**-dev**.properties——————-&gt;server.port&#x3D;8080。。。。。\n\napplication**-pro**.properties——————-&gt;server.port&#x3D;8090。。。。。\n\n\n\n\n\n带参数启动\n\njava -jar springbootXXX.jar --spring.profiles.active=pro\n\n\nmaven控制boot多环境开发\n\n\n① 在pom文件中加入多环境配置\n\n&lt;profiles&gt;    &lt;!--开发环境--&gt;    &lt;profile&gt;        &lt;id&gt;dev&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;dev&lt;/profile.active&gt;        &lt;/properties&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;        &lt;/activation&gt;    &lt;/profile&gt;    &lt;!--生产环境--&gt;    &lt;profile&gt;        &lt;id&gt;pro&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;pro&lt;/profile.active&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;\n\n\n② 导入让maven配置加载入资源配置的插件\n\n&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;    &lt;version&gt;3.2.0&lt;/version&gt;    &lt;configuration&gt;        &lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;    &lt;/configuration&gt;&lt;/plugin&gt;\n\n\n③ 使用$&#123;Value&#125;的形式在yaml中使用\n\nSpringBoot整合Mybatis\n区别：\n\n无需手写MybatisConfig和JdbcConfig，SpringBoot将自动生成\n无需手动导入properties，只需要在SpringBoot配置中写上dataSource有关参数\n无需手动扫描mapper，只需要在原来mapper类上加入@Mapper注解，SpringBoot将自动扫描该类\n\n\n注意：\n\n生成项目时应加入Mybatis和mysql的起步依赖\n如需要更改数据源类型，只需要导入依赖并在dataSource配置中加上type参数即可\n\n\n\n"},{"title":"SpringBoot高级","url":"/2023/05/31/SpringBoot%E9%AB%98%E7%BA%A7/","content":"日志的管理\nSpringBoot默认使用logback类来记录日志（slf4j模板）\n\n使用方法：在需要写日志的类中加上Logger（slf4j包）对象并传入该类名称即可记录日志\n或：使用Lombok中的@slf4j注解\n\n\n使用Log.info()添加日志\n\n可以通过修改logging.console.pattern来更改日志格式\n\n设置日志文件\nlogging: file:  name: server.log\t# 生成的日志文件名\n\n日志详细配置\nlogging: file:  name: server.log\t# 生成的日志文件名 logback:  rollingpolicy:   max-file-size: 3KB\t\t\t\t\t\t\t\t# 文件切分的大小   file-name-pattern: server.%d&#123;yyyy-MM-dd&#125;.%i.log\t# 文件切分的文件名\n\n热部署\n作用：由于SpringBoot内置tomcat，因此需要配置boot热部署来检测web工程是否发生更改\n\n原理：热部署仅仅加载当前开发者自定义开发的资源，不包括jar包\n\n手动启动热部署\n\n添加spring-boot-devtools依赖\n使用构建项目（ctrl+F9）\n\n\n自动启动热部署\n\n添加以上的依赖，并打开idea设置-&gt;构建、执行、部署-&gt;自动构建\n\n在idea下按  ctrl-alt-shift-&#x2F;  并打开注册选项，勾上automake.when.app.running\n\n则在idea失去焦点5秒后自动构建项目\n\n可以在boot配置文件中配置不参与热部署的文件\n\n\n\n\n关闭热部署\n\n使用更高等级属性覆盖enabled配置（如System.SetProperty()）\n\n\n\n高级配置第三方或自定义Bean的配置\n作用：使用SpringBoot配置文件中的配置加载第三方或自定义Bean\n\n特点：可以进行松散绑定，无需名称完全一致\n\n方法：在对应类上加入@ConfigurationProperties(prefix = &quot;aaa.bbb&quot;)注解，其中prefix中写入需要的配置的父名称\n\n如：\naaa: bbb:  name: &quot;frank&quot;  age: 20\n\n@Data@Component\t\t//注意，如果在Spring配置中开启配置属性的功能则不用加Component@ConfigurationProperties(prefix = &quot;aaa.bbb&quot;)public class Person &#123;    private String name;    private int age;&#125;\n\n\n注意：使用时应加入spring-boot-configuration-processor依赖\n\n如果配置中需要配置单位，可以使用Duration（时间），DataSize（储存大小）两个类型使用@DurationUnit()和@DataUnit()配置单位\n\n\nBean属性校验\n起因：使用配置进行Bean配置时需要进行字段校验\n原理：使用JSR303校验规范\n步骤：\n添加JSR303规范（validation-api）和Hibernate校验框架（规范的实现）的坐标\n在需要校验的类上加入@Validated注解，开启校验\n在需要校验的字段上加入对应规则的注解，如@MAX，@MIN\n\n\n\n高级测试添加临时属性\n作用：在测试类中使用特定属性，只在该类中生效\n两种实现方法：\n在SpringBootTest注解中加入properties属性，如@SpringBootTest(properties=&#123;&quot;test.name=Steveny&quot;&#125;)\n在SpringBootTest注解中加入args属性，如@SpringBootTest(args=&#123;&quot;--test.name=Franky&quot;&#125;)\n\n\n\n\n注意：使用命令行的args属性的优先级要高于使用boot配置\n\n添加临时的Bean\n需求：在测试类中运用特殊的Bean仅供测试类使用\n方法：在测试目录下创建Config类并在用来测试的类上加入@Import注解导入配置\n\n表现层测试\n原理：Spring发送虚拟请求到指定路径并获得请求的回复\n\n步骤：\n\n启动Web测试环境，在@SpringBootTest注解中加入webEnvironment值来开启Web环境\n在测试类上加入@AutoConfigureMockMvc注解打开测试\n自动装配MockMvc对象\n声明MockHttpServletRequestBuilder实体类，并使用MockMvcRequestBuilders工具类创建请求\n使用MockMvc对象的perform方法执行，返回请求结果\n\n\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)@AutoConfigureMockMvcpublic class testController &#123;    @Test    void testController(@Autowired MockMvc mockMvc) throws Exception &#123;        MockHttpServletRequestBuilder request = MockMvcRequestBuilders.get(&quot;/user&quot;);        ResultActions action = mockMvc.perform(request);    &#125;&#125;\n\n\n校验请求结果：MockMvcResultMatchers\n\n@Testvoid testUser(@Autowired MockMvc mockMvc) throws Exception &#123;    MockHttpServletRequestBuilder request = MockMvcRequestBuilders.get(&quot;&quot;);    ResultActions action = mockMvc.perform(request);    StatusResultMatchers status = MockMvcResultMatchers.status();\t\t//状态    ContentResultMatchers content = MockMvcResultMatchers.content();\t//Body内容    ...    ResultMatcher resultMatcher1 = status.isOk();    ResultMatcher resultMatcher2 = content.string(&quot;asd&quot;);\t    action.andExpect(resultMatcher1);    action.andExpect(resultMatcher2);&#125;\n\n\n\n业务层测试事务回滚\n方法：在测试类上加入@Transactional注解即可\n注意：如果加上@Transactional注解之后想提交事务可以再加上@Rollback(false)注解\n\nWebSocket\n简介：\n\nWebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）\n它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的\nWebsocket是一个持久化的协议\n\n\nSpringBoot实现：\n\n导入websocket的starter\n\n创建ServerEndpointExporter的bean对象，用来注册带有@ServerEndpoint注解的类\n@Configurationpublic class WebSocketConfig &#123;    @Bean    public ServerEndpointExporter serverEndpointExporter() &#123;        return new ServerEndpointExporter();    &#125;&#125;\n\n创建Endpoint的实体类，用来表示单个客户端在服务器中的对象，会有多个，并指定一个路径进行监听\n@ServerEndpoint(value = &quot;/game&quot;, configurator = GetHttpSessionConfigurator.class)\t//重要！！！！@Componentpublic class GameEndPoint &#123;    //用来存储每个用户客户端对象的ChatEndpoint对象    private static Map&lt;String, GameEndPoint&gt; onlineUsers = new ConcurrentHashMap&lt;&gt;();    //声明session对象，通过对象可以发送消息给指定的用户    private Session session;    //声明HttpSession对象，我们之前在HttpSession对象中存储了用户名    private HttpSession httpSession;    //连接建立    @OnOpen    public void onOpen(Session session, EndpointConfig config) &#123;    &#125;    //收到消息    @OnMessage    public void onMessage(String message, Session session) &#123;    &#125;    //关闭    @OnClose    public void onClose(Session session) &#123;    &#125;&#125;\n\n如果需要调用HttpSession记得配置ServerEndpointConfig.Configurator中的modifyHandshake方法，将httpSession对象放在EndpointConfig中\npublic class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator &#123;    @Override    public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) &#123;        HttpSession httpSession = (HttpSession) request.getHttpSession();        sec.getUserProperties().put(HttpSession.class.getName(), httpSession);    &#125;&#125;\n\n\n\nRedis简介\nRedis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\n\nRedis 与其他 key - value 缓存产品有以下三个特点：\n\nRedis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n\nRedis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n\nRedis支持数据的备份，即master-slave模式的数据备份。(Copied)\n\n\n\n简单使用：使用自动装配的RedisTemplate对象，根据操作类型的不同，生成不同的值操作对象，如：\nStringRedisTemplate redisTemplate;\t\t//推荐，操作redis客户端，可以避免产生乱码ValueOperators ops = redisTemplate.opsForValue();Object val = ops.get(&quot;testKey&quot;);System.out.println(val);\n\n缓存Simple和Ehcache\n缓存（Cache）是一种介于数据永久储存介质与数据应用之间的数据临时储存介质，可以加快读写速度\n\n作用：不仅可以存储从数据库读取的数据，也可以存储临时数据\n\nBoot缓存使用：\n\n导入依赖cache的starter\n\n在容器上加入@EnableCaching注解开启缓存服务\n\n在使用缓存的方法上加入@Cacheable注解\n@Cacheable(value = &quot;service&quot;, key = &quot;#id&quot;)//@CachePutpublic User getUserById(String id) &#123;\treturn userDao.selectById(id);&#125;\n\n\n@Cacheable中value指的是缓存的命名空间，key指的是缓存对应的键值，#id表示引用id变量\n\n\n\n\n@CachePut注解：只将值放入缓存而不读取缓存\n\n注意：@Cacheable注解只能在Bean中使用，不能在方法调用中生效\n\n更换ehcache缓存技术：1. 导入坐标 2. 配置spring配置缓存类型 3. 导入ehcache的配置文件\n\n\n数据淘汰策略\nLRU（Least Recently Used）：挑选最近最少使用的数据淘汰\nLFU（Least Frequently Used）：挑选近期使用次数最少的数据淘汰\nTTL（Time To Live）：挑选即将过期的数据淘汰\n\nJetCache\nJetCache对SpringCache进行了封装，在原有功能基础上实现了多级缓存、缓存统计、异步调用、数据报表等功能\n\n能兼容LinkedHashMap和Caffeine本地缓存，Redis和Tair远程缓存、\n\n基本使用：\n\n依赖 jetcache-starter-redis（非SpringBoot整合）\n\n在Spring容器上开启CreateCache注解@EnableCreateCacheAnnotation，@EnableMethodCache（方法注解，传入包名）\n\n在Spring配置文件中加入jetCache配置\njetcache: local:  default:   type: linkedhashmap\t\t# 本地缓存方案   keyConvertor: fastjson\t# 键转换器 remote:  default:   type: redis   host: localhost   port: 6379   keyConvertor: fastjson   valueEncode: java\t\t# 序列化对象的形式   valueDecode: java   poolConfig:\t\t# 必须要求至少有一条配置    maxTotal: 50  msmCode:\t\t\t# 可以根据环境进行自定义配置  ...\n\n在缓存对象上加入@CreateCache注解（已弃用）\n@CreateCache(area = &quot;msmCode&quot;, name = &quot;pokerUser_&quot;, expire = 3600, cacheType = CacheType.LOCAL)//area指使用的配置，name指key的前缀，expire指存活时间（单位：秒 可自定义）, cacheType指缓存方案 远程、本地或两者private Cache&lt;String, String&gt; jetCache;\n\n在缓存方法上加入@Cached注解（已弃用）\n@Cached(name = &quot;msmCode_&quot;, expire = 3600, cacheType = CacheType.LOCAL)//name指key的前缀，expire指存活时间（单位：秒 可自定义）, cacheType指缓存方案 远程、本地或两者public User getUserById(Long id) &#123;\t//...&#125;\n\n\n重要：如果需要存入java对象，则需要使java对象实现序列化\n\n\n\n\n\n"},{"title":"孤星","url":"/2023/05/31/%E5%AD%A4%E6%98%9F/","content":""},{"title":"操作系统","url":"/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"Operating System1. Introduction Of Operating System\nOperating system manages all of the hardware resources of a computer and makes it easy to use.\nUser &lt;–&gt; Application &lt;–&gt; Operating system &lt;–&gt; Hardware\nThe function of operating system:\nAllocation and Management of Resources among computer user processes. （分配和管理计算机资源）\nMaximising Resource Utilisation with the goal of improving overall system throughput.（提升资源利用率）\nProviding a user interface and an application interface to the machine.（提供用户界面和程序接口）\nCoordinating the many concurrent activities and devices, handling input and output from attached hardware and ensuring correct synchronisation and communication is achieved.（管理多线程任务和设备输入输出）\nActing as a Resource Guardian to protect various resources of the computer system from malicious or accidental misuse.（保护资源不被滥用）\nAccounting for periods of resource usage by user processes, enforcing quotas or restrictions as appropriate. （合理分配计算资源）\nPower and Thermal Management.（电力和温度管理）\n\n\n\n2. Program, Process and Processor\nProgram, Process and Processor\n\nProgram\n\nA program is a collection of instructions specifying a defined sequence of execution. It is the translation of an algorithm into a programming language.（程序是指令集，是代码的程序语言）\n\n\nProcess\n\nA process is an instance of a program in action. It is an operating system abstraction. When the instructions are being carried out, a process exists.（进程是程序的实例，当对应指令执行时，则称进程被运行，是一个抽象概念）\nThe program image has a format specific to a particular operating system and processor.（程序要特定操作系统和处理器）\nA process is an execution context, a collection of kernel managed information needed while it is running. \nProcesses are dynamic entities whose lifetimes range from a few milliseconds to maybe months. （可以很短）\nProcesses may be persistent, implementing system services.（也可以很长）\n\n\nProcessor\n\nA processor is the agent which runs a process by executing the instructions stored in the memory image. (执行指令)\n\n\n\n\nRepresenting Process Abstractions\n\nA fundamental task of an operating system is process management – Creating, Controlling, Terminating –Managing the Execution Environment（线程的创建，控制，终止和管理执行环境）\nFor each process, the operating system maintains a process control block (PCB) or process descriptor to keep a clear picture of what each process is doing, what point it has reached in its execution and what resources have been assigned to it.（进程控制块保存进程信息）\nA Process Control Block is used to keep track of the execution context (all resource information about the process and its activity) that can be used for independent scheduling of that process onto any manprocessor.（上下文和资源使用信息）\n\n\nProcess Identification Data（比如PID）， Processor State（比如寄存器内容）， Process Control Data（标志寄存器内容）\n\n\nProcess Lifecycle\n\nThe PCB may be moved between different queues over the process lifetime depending on the priority or state of its execution. （根据优先级移动队列）\n\nQueues hold processes waiting for different resources which are serviced using scheduling algorithms.（队列管理等待中的进程）\n\nProcess Creation —— Process Ready —— Running —— Waiting —— Terminate\n\nSystem Calls and Hardware Interrupts\n\nThe processor executes in one of two modes, User Mode or Supervisor Mode. When executing a user process the processer is in User Mode, and can only execute a subset of its instruction set. To execute operating system code, the processor must be switched to Supervisor Mode in a controlled manner and can then execute its full instruction set. （用户模式和监督模式）\nA special processor instruction known as a software interrupt is the mechanism for doing Switching to Supervisor Mode.\nSystem Calls are often accessed through wrapper libraries linked with the user space process. （不受内核限制）\nThe Hardware Interrupt mechanism is needed to enable the system to effectively manage a large number of hardware devices efficiently\n\n\n\n3. Process scheduling\nProcess Scheduling\n\nEach process must compete with others for the available resources. \n\nContext Switch \n\nIt saves the run-time state of the current process in the process control block so that it can be continued later, and then executes dispatcher code to load the run-time state of the chosen process for the CPU to continue executing instead. （上下文切换）\n\n\nasymmetric multiprocessing\n\nOne CPU for scheduling and allocating resources.\n\n\nsymmetric multiprocessing\n\nAll processors carry out similar functions and are self scheduling.\n\n\nTimes\n\nProcessor Utilisation &#x3D; (Execution Time) &#x2F; ( Total Time) \n\nThroughput &#x3D; Jobs per Unit time \n\nTurnaround Time &#x3D; (Time job finishes) - (Time job was submitted) \n\nWaiting Time &#x3D; Time doing nothing in a queue\n\nResponse Time &#x3D; (Time job is first scheduled on cpu) - (Time job was submitted)\n\n\n\n\n\nScheduling Algorithms\n\nnon-preemptive（非抢占式调度，即一个进程正在执行，则其他进程阻塞）\nFCFS (First Come First Served)\nFair but performs badly for interactive systems\n\n\nSJF (Shortest Job First) \nNot fair but optimal\n\n\nHRN(Highest Response Ratio Next)\n根据等待时间和执行时间的比值决定下一个任务\n\n\n\n\npreemptive（抢占式调度，即一个重要的进程将要执行，则会强制切换上下文）\nRR(Round Robin)\n根据时间片大小循环执行每个任务，时间片过小会产生大量上下文切换，时间片过大会退化成FCFS\n\n\n\n\n\n\n\n4. Disk Scheduling\nConstruction of disk\n\nSmaller platter diameters offer better rigidity, weigh less and require less power to spin, meaning more useful with portable devices&#x2F;usb power, less noise and heat and improved seek performance. \n\nA sector&#x2F;block is the smallest storage unit of data that can be addressed, read from or written to the disk.（扇区）\n\nEach platter surface has a read&#x2F;write head which can move linearly across it. （读写头）\n\n\n\nSectors\n\nThe contents of each sector area include sector id information, sector status codes, synchronization bit patterns to guide the read head, 512 or 4k bytes of data, error correction codes and sector gaps. （扇区，id，状态码）\nThe number of sectors stored on inner tracks is constrained by the bit density of the magnetic surface. \nThis also means that if the rotational velocity is constant, that data can be transferred faster from the outer tracks than the inner tracks. （如果转速恒定，则磁盘外圈的读写速度比内圈快）\n\n\nSolid State Drives\n\n20-40 times faster than standard storage.\nPerformance:\nCapacity（容量大）\nData Rate（带宽大）\nAverage Latency（读写平均）\nReliability（可靠）\n\n\n\n\nScheduling Algorithms\n\nThe slowest part of accessing a disk block is physically moving the head to the correct track. This is called the seek time.（移动读写头占用了大量时间） \nNative Command Queuing (NCQ) is an extension of the SATA protocol allowing hard disk drives to internally optimize the order in which received read and write commands are executed.（当用户的应用程序发送多条指令到硬盘，NCQ硬盘可以优化完成这些指令的顺序，从而降低机械负荷达到提升性能的目的）\nDifferent Schedules:\nFCFS （First come first served）：先来后到\nSSTF（Shortest seek time first）：从当前读写头所在位置附近的地方开始，每次去找离当前位置最近的数据\nSCAN：读写头在磁盘内反复扫描，像“&gt;”一样，期间不改变扫描方向\nC-SCAN：每次都从头扫到尾，像”\\\\“一样，期间不改变扫描方向\nLOOK：和SCAN一样，但如果该次扫描方向上没有其他读写请求则会反转移动方向\nC-LOOK：和C-SCAN一样，但如果该次扫描方向上没有其他读写请求则会反转移动方向\n\n\n\n\n\n5. Unix Process\nUnix Process Creation\n\n使用fork()创建进程，最初的进程为父（parent），新创建的进程为子（child）\nChild process is an exact copy of the parent including a copy of the parent’s I&#x2F;O descriptor table, so it inherits access to all the parent’s open I&#x2F;O devices.（子进程会继承父进程的I&#x2F;O描述表）\nexec()函数将执行一段二进制代码\nwait()函数将等待直到一个子进程的结束，并返回子进程的PID，如果失败则返回-1。\n\n\nBooting a Linux System\n\nAfter power on self test and hardware identification by firmware routines, the first boot device is selected and the Master Boot Record, the first sector on the drive, is read from that device. The MBR contains initial bootstrapping code and information about the active partition. （当固件自检和其他例程结束后，将读取第一个扇区的MBR）\nMaster Boot Record (MBR) contains initial bootstrapping code called by the BIOS and partition information about the primary boot device and the active partition.（含有BIOS）\n\n\nInterprocess Communication（进程间通信）\n\nWhere to use:\nData Parallelization for Computational Speedup.（加速计算）\nModular, Pipelined or Layered Division of functions or microservices within an application.（程序模块化，管道化）\nClient use of a service on a network.（网络客户端）\n\n\nTwo ways:\nShared Memory Communication（共享内存）\nModel is application oriented, suits cooperating processes willing to share memory.（面向应用程序）\nImplicit communication through read&#x2F;write operations.（通过读&#x2F;写操作通信）\nHighly efficient, no communication protocols.（无通信协议的高效通信）\nNeed synchronisation mechanisms.（但需要高度同步机制）\n\n\nmessage passing primitives（消息密语）\n问题一：The message passing operations Send and Receive may be either blocking or non-blocking. （消息的发送和接收可以是阻塞的，也可以是不阻塞的）\n问题二：Buffering adds complexity and the need for message sequencing.（缓冲区大小不定）\n问题三：Packets can be of fixed or variable size, typed or untyped messages. （数据包大小不定）\n问题四：The mechanism must deal with the problems of networked communication such as lost and scrambled messages, and also with security issues. （网络中断问题）\n\n\n\n\n\n\nInterprocess Communication in Unix（Unix系统的进程间通信机制）\n\n第一种：Pipe（管道）\nPipes are FIFO byte stream communication channels implemented with finite size memory buffers maintained by the kernel. （管道是一种固定字节流的FIFO通信通道，由有限大小的缓冲区实现和维护）\n\nA process writes data to one end of the pipe, and usually another process reads it from the other end. A pipe exists for the lifetime of the processes that have access to it. （管道由进程维护，生命周期由进程决定）\n\nA pipe can only be used between related processes and is generally used as a unidirectional communication channel from parent to child or vice versa. The parent would create the pipe before creating the child so that the child can inherit access to it.（管道创建早于子进程的创建且是单向的）\n\npipe在C语言中的使用方法：\nint main() &#123;    int fdptr[2], n, buffersize=21;\t// 如果一次读的字符数多于管道内，则会返回已读的字符    char strbuff[buffersize+1];    char message[] = &quot;Welcome to Unix pipes&quot;;    int pid;    \tpipe(fdptr); \t\t\t\t\t// Create a new pipe，其中fdptr[0]是读取管道，fdptr[1]是写入管道\tpid = fork();\t\t\t\t\t// 子进程继承父进程的管道    if (pid == 0) &#123;        while (true) &#123;            /* read from the pipe into strbuff */\t\t\tn = read(fdptr[0], strbuff, buffersize); // 参数：（管道，需要写入的内容，写入量）\t\t\tstrbuff[n]=0;            printf(&quot;Child read: %s\\n&quot;, strbuff);            sleep(5);        &#125;    &#125;    else &#123;        while (true) &#123;            printf(&quot;Parent writing: %s\\n&quot;, message);            /* write message into the pipe */\t\t\twrite(fdptr[1], message, strlen(message)); // 参数：（管道，用来存储内容的变量，写入量）\t\t\tsleep(5);        &#125;    &#125;&#125;\n\n\n第二种：Named Pipe（命名管道）\nA variation of this mechanism known as a named pipe, can be used for communication between unrelated processes that have access to the same file name space.（可以被同一文件夹下的不同进程访问）\n\n// To create a named pipe file called “mypipe” in the current directory, use:-\nmknod(&quot;mypipe&quot;, 010777, 0);\n// 参数代表（名称，权限，无关变量），权限中的010是NamedPipe的特殊标识，777代表全部权限\n\n// Processes open named pipes in the same way as regular files, so \n// unrelated processes can communicate by opening the pipe and \n// either reading or writing it.\n// A process can open a pipe in read or write mode.\nnamedpipe = open(“mypipe&quot;,O_WRONLY);\nnamedpipe = open(“mypipe&quot;,O_RDONLY);\n- ##### 第三种：Socket（套接字）  - A socket is a data structure created by an application to represent a communication channel. The socket must be bound or associated to some entity (service access point/port) within the communication system. （网络通信通道）  - The communication service (e.g TCP/IP) provides the glue for establishing connections between sockets belonging to different processes, which are often on different machines and networks and for transporting and routing messages through the network to a destination. （TCP/IP保证了多设备的网络通信）  - On the Internet, IP addresses and port numbers are used as a means of identifying the endpoints of a connection to which a program’s socket might be connected.（IP地址和端口号作为端的唯一标识）- ##### 第四种：Remote Procedure Call（远程过程调用）  - RPC is a more convenient communication abstraction built on top of an underlying endpoint connection mechanism like sockets over TCP/IP which is intended to make client server programming easier. It enables you to call a remote function in a similar manner to a local one.（可以像在本地调用函数一样调用远程函数）  - 难点一：Arguments are passed by value, as in the remote address space, pointer references cannot be evaluated correctly. This makes it difficult to pass memory pointer based data structures or object references for example. （指针引用困难）  - 难点二：It will be necessary for the RPC mechanism to find an agreeable external data representation format for representing the information exchanged so that it is interpreted correctly by both parties. （需要合适的数据交换格式）- ##### 第五种：Message Queues（消息队列）  - Message queues allow processes to exchange data in the form of **whole messages** asynchronously. No rendezvous required.（可以异步的交换数据）  - Messages have an **associated** **priority** and are queued in priority order.（消息队列是有优先级的）  - 消息队列对比管道的特点：    - Internal structure and geometry set by user（有内部结构，管道没有）    - Separate messages are distinguishable（消息内容可区分，管道不能）    - Queue sorted on message priority（消息有优先级，管道没有）    - Process can determine status of queue, maximum msg size（进程可以知道消息队列的状态和大小，管道不能）  - ```c    mq_open() \t// function creates a new message queue or opens an existing queue, returning a \t\t\t\t   message queue descriptor for use in later calls.    mq_send()   // function writes a message to a queue.    mq_receive() // function reads a message from a queue.    mq_close()\t // function closes a message queue that the process previously opened.    mq_unlink()  // function removes a message queue name and marks the queue for deletion when all \t\t\t\tprocesses have closed it.\n\n\nint main (int argc, char *argv[]) &#123;\n   int modeflags = O_CREAT | O_WRONLY; /*Create if it doesn’t exist*/\n   mode_t permissions = 0600; /* Read/Write for owner only */\n   struct mq_attr attr;\n   mqd_t mq;\n\n   char qname [20];\n   int max_size =512;\n   char buffer[max_size];\n   int priority;\n\n   strcpy(qname, &quot;/test_queue&quot;);\n\n   attr.mq_flags = 0; /* Blocking allowed mode */\n   attr.mq_maxmsg = 10;\n   attr.mq_msgsize = max_size;\n\n   mq = mq_open(qname, modeflags, permissions, &amp;attr);\n   if (mq &lt; 0) &#123;\n      printf(&quot;Couldn&#39;t create queue %s\\n&quot;,qname);\n      exit(-1);\n   &#125;\n\n   for (priority = 1; priority&lt;=10; priority++) &#123;\n           memset(buffer,0, max_size); /* Clear all buffer locations to 0 */\n        sprintf(buffer, &quot;%d&quot;, priority); /* Convert int &quot;priority&quot; to string and store in buffer*/ \n        strcat(buffer,&quot; message text&quot;); /* The message we want to send */\n\n        mq_send(mq, buffer, strlen(buffer), priority); \n    &#125;\n   \n   if (!mq_close(mq))\n      printf(&quot;Closed the queue\\n&quot;);\n&#125;\n### 6. Threads- Modern operating systems support the model of a single process environment supporting multiple threads of control executing independently at different points within the process’s code.（现代操作系统支持执行多个线程来代替进程）- **Better Resource Usage / Quicker to Create**（更好的资源使用和更快的创建速度）- **User Space Threads**（用户空间线程）  - 优点：    - This implementation does not require any operating system support for threads. Invoking a function in the library to create or destroy a thread or schedule a thread can be handled very fast as a local function call in user space, which manipulates local data structures for controlling user defined threads and what the program is doing at a given moment. （线程可以直接调用本地库而不是需要操作系统的支持来快速处理）  - 缺点：    - A context switch to the kernel would block all threads in the process, as the kernel is unaware of the existence of separate thread abstractions manipulated within the application context. （在内核中的上下文切换将阻塞所有线程）    - Scheduling of threads by the user space thread library would be non preemptive.（线程的调度是非抢占性的）    - And the application can’t benefit from multicore processing.（该程序将无法从多核CPU中获益）- **Kernel Space Threads**（内核空间线程）  - 优点：    - Implementing threads in kernel space offers greater flexibility and efficiency. A thread issuing a system call does not necessarily block all other threads in that process. （系统调用的线程将不会阻塞其他线程）    - Threads can be scheduled onto separate CPUs on a multiprocessor system offering true application concurrency. （可以被调度到多核CPU中）    - Threads compete on an equal basis for CPU cycles and they may be preempted by hardware timers easily.（平等竞争，可以被硬件计时器抢占）- POSIX Standard was developed to provide a common abstraction or virtualization of operating system services by making system calls standard across all Unix system varieties, enhancing code portability.### 7. Mutual Exclusion Problem- 互斥问题简介：两个线程访问同一资源时会出现互斥- 互斥问题解决的三个标准：  - **Mutual Exclusion**:\tNo two threads can be able to execute simultaneously in the critical code section.（在同一时间内必须保证在同一时间内只有一个线程访问共享资源）  - **Progress**:     A thread operating outside the critical section cannot prevent another thread form entering the critical section.（任何外部线程不能影响另一个线程的访问）  - **Bounded Waiting**:    Once a thread has indicated its desire to enter a critical section, it is guaranteed     that it may do so in a finite time.（线程在访问资源的过程的时间是有限的）- 解决方案一：  - ```c    int flag = 0; /* Shared variable between the threads Initially 0 */    while (flag == 1) &#123;&#125; // 线程等待    flag = 1;     // Enter the Pass     // ...     // Leave the Pass     flag = 0;\n\n\n\n\n问题：当两个线程同时得知flag不为1时，便会一起被释放。\n\n\n\n解决方案二：\n\nint turn = 0;/* Shared variable between the processes, initially 0 */\n// 一个线程\nwhile (turn == 0) &#123;&#125; \nEnter Pass Enter Pass \n... ... \nLeave Pass Leave Pass \nturn = 0;\n\n//另一个线程\nwhile (turn == 1) &#123;&#125; \nEnter Pass Enter Pass \n... ... \nLeave Pass Leave Pass\nturn = 1;\n  - 问题：解决了互斥问题，但步骤是锁定的，只有两个线程。- 解决方案三：  - ```c    boolean[] flags = &#123;false, false&#125;;    // 一个线程    flag[0] = true;    while(flag[1]) &#123;&#125;    ...    flag[0] = false;        // 另一个线程    flag[1] = true;    while(flag[0]) &#123;&#125;    ...    flag[1] = false;\n\n\n问题：当两个线程同时设定自己的flag为true时，会发生死锁。\n\n\n\n解决方案四：\n\nint flag = 1; /* Shared variable between the processes initially 1 */\nwhile (flag == 0) &#123;&#125; /*Do nothing while Flag=1*/ \nflag = 0;\nEnter the Pass \n... \nLeave the Pass \nflag = 1;\n  - 问题：与方案一相同。- 最终解决方案：**Bakery Algorithm** 面包店算法  - ```c    boolean[] choosing;  // 记录对应线程是否正在买票    int[] number; \t\t // 记录每个线程得到的票的id        // 对于线程i：    choosing[i] = true; \t\t\t\t\t\t\t\t\t// 设定自己的状态为正在买票    number[i]=Max(number[0],number[1], ...,number[n-1])+1; \t// 将自己的票的id设定为最大值 + 1    choosing[i] = false;\t\t\t\t\t\t\t\t\t// 恢复        // 对于所有其他线程j1, j2, j3...：    for (j = 0; j &lt; n; j++) &#123;    \twhile choosing[j] &#123;&#125;\t\t\t\t\t// 如果自己正在买票，则等待自己买完票    \twhile ((number[j] != 0) &amp;&amp; ((number[j],j) &lt; (number[i],i))) &#123;    \t\t// 如果有线程票的id比自己小，则等待    \t&#125;    &#125;        ...   // 获得资源        number[i] = 0;  //将自己的票设为0，即没买过票\n\n\n\n\n\n8. Semaphore\n前者算法的不足之处：\n\nOne of the problems with this scheme is that the entry and exit code and associated shared data structures are a bit unwieldy and awkward when used by a programmer to protect any arbitrary critical section.（使用繁琐且数据结构复杂）\n\nAll of these software solutions involve Busy Waiting - an execution loop in the code where the thread continually tests the locking condition during its scheduled timeslice until the condition allows it to continue into the critical section. （多次循环导致忙等待）\n\n\n\nBusy Waiting（忙等待）\n\nThis is OK if the waiting period is short, but not for long waits, we need to suspend the process.（当处理时间较长时，忙等待将会降低系统性能）\nPriority inversion can occur where a lower priority task in the critical section may hold a lock which causes a higher priority task to wait.（可能会导致优先级反转）\n\n\nSemaphore\n\nIn its classical definition, a semaphore consists of a shared integer variable accessible only through two defined operations, P &amp; V, (sometimes known as Wait and Signal, or Acquire and Release). （P代表获取，V代表释放）\n两种Semaphore：\nWhen the semaphore value is used to control mutual exclusion, then a binary semaphore is used which can only have the value 0 or 1. It is used as a mutex locking mechanism.（单例共享）\nA counting semaphore (or rate limiting semaphore) can also be implemented by setting the count value to a maximum number (say n) of threads allowed into a region of code at one time. （多个共享）\n\n\n核心思想：通过请求Semaphore的方式来简单的获取和释放共享资源。\n避免繁琐的数据结构和忙等待问题，保证了线程的公平性\n\n\npublic class Semaphore &#123;\n    private int value;\n    \n    public Semaphore(int value) &#123;\n        this.value = value;\n    &#125;\n\n    public synchronized void acquire() &#123;\n        while (value == 0) &#123;\t\t// 循环的意义是防止notify方法唤醒错误的线程\n            try &#123;\n                // Calling thread waits until semaphore is free\n                wait();\n            &#125; catch(InterruptedException e) &#123;&#125;\n        &#125;\n        value = value - 1;\n    &#125;\n\n    public synchronized void release() &#123;\n        value = value + 1;\n        notify();\n    &#125;\n&#125;\n### 9. Classical Problems##### The Producer/Consumer Problem- 描述：一个生产者和消费者分别持续生产和消费，会产生线程安全问题。- 核心思想：使用一个缓冲区来管理生产者和消费者，设定一个empty和一个full的Semaphore来分别判断一个线程是从能从缓冲区中添加或者删除一个元素。-   ```java  // Buffer  public class Buffer &#123;  \tprivate static final int BUFFER_SIZE = 5;  \tprivate Object[] buffer;  \tprivate int in, out;  \tprivate Semaphore mutex;  \tprivate Semaphore empty;  \tprivate Semaphore full;    \tpublic Buffer() &#123;  \t\tin = 0;  \t\tout = 0;  \t\tbuffer = new Object[BUFFER_SIZE];  \t\tmutex = new Semaphore(1);  \t\tempty = new Semaphore(BUFFER_SIZE);  \t\tfull = new Semaphore(0);  \t&#125;    \tpublic void insert(Object item) &#123;  \t\tempty.acquire();\t\t\t\t// 当empty被获取完时，等待消费者消费  \t\tmutex.acquire();\t\t\t\t// 顺序十分重要！不然会发生死锁！  \t\tbuffer[in] = item;  \t\tin = (in + 1) % BUFFER_SIZE;  \t\tmutex.release();  \t\tfull.release();\t\t\t\t\t// 提醒消费者消费  \t&#125;    \tpublic Object remove() &#123;  \t\tfull.acquire();\t\t\t\t\t// 当full被获取完时，等待生产者生产  \t\tmutex.acquire();\t\t\t\t// 顺序十分重要！不然会发生死锁！  \t\tObject item = buffer[out];  \t\tout = (out + 1) % BUFFER_SIZE;  \t\tmutex.release();  \t\tempty.release();\t\t\t\t// 提醒生产者生产  \t\treturn item;  \t&#125;  &#125;\n\n\n\nDining Philosophers Problem\n问题描述：5个哲学家在一桌吃饭，但桌上只有5根筷子，一个哲学家每次吃饭前都要有两根筷子。\n\n通常解决：将每根筷子都设定为Binary Semaphore，每次吃饭前取走筷子，吃饭后释放筷子。\n\n通常解决的问题：当5个人同时取走一根筷子时，将会发生死锁。\n\n解决方案一：\n\n一次只允许4名哲学家获取筷子，也就是说一桌同时只能有4个人同时吃饭。\n\nclass Philosopher extends Thread &#123;\n    private int myName;\n    private Semaphore chopSticks[];\t\t\t// new Semaphore(1) 指一根筷子只能同时一个人用\n    private Semaphore room;\t\t\t\t\t// new Semaphore(4) 指一个房间同时只能有4个人\n    \n    public void run() &#123;\n        while (true) &#123;\n            // thinking\n            room.acquire();\t\t\t\t\t\n            chopSticks[myName % 5].acquire(); // Acquire left\n            chopSticks[(myName + 1) % 5].acquire(); // Acquire right\n\n            // eating\n\n            chopSticks[myName % 5].release(); // Release left\n            chopSticks[(myName + 1) % 5].release(); // Release right\n            room.release();\n        &#125;\n    &#125;\n&#125;\n- 解决方案二：  - 通过互斥锁保证哲学家在获取筷子时一次获取两根筷子。  - ```java    class Philosopher extends Thread &#123;        private int myName;        private Semaphore chopSticks[];        private Semaphore mutex;        private boolean haveChopSticks;            public void run() &#123;            while (true) &#123;                // thinking                                haveChopSticks = false;                while (!haveChopSticks) &#123;                    mutex.acquire();                    if ((chopSticks[myName % 5].getValue() == 1) &amp;&amp; (chopSticks[(myName + 1) % 5].getValue() == 1)) &#123;\t\t\t\t\t\t\t\t\t// 保证一次能获取两根筷子                        chopSticks[myName % 5].acquire(); // Acquire left                        chopSticks[(myName + 1) % 5].acquire(); // Acquire right                        haveChopSticks = true;                    &#125;                    mutex.release();                &#125;                // eating                                chopSticks[myName % 5].release(); // Release left                chopSticks[(myName + 1) % 5].release(); // Release right            &#125;        &#125;    &#125;\n\n\n\n\n\nReaders&#x2F;Writers Problem\n问题描述：对数据的读&#x2F;写需要严格的权限管理，以确保读写的正确性。\n\n优先考虑读者的解决方案：\n\n即只有所有读者都读完之后，作者才能开始写。不同读者可以轮流读，但不同作者不能轮流写。\n\npublic class DataAccessPolicyManager &#123;\n   private int readerCount;\n   private Semaphore mutex;\n   private Semaphore wrt;\n\n   public void acquireReadLock() &#123;\n      mutex.acquire();\t\t\t// synchronized\n      ++readerCount;\n      if (readerCount == 1) \t// 当第一个读者开始读时，拿走互斥锁；当所有读者读完时，归还互斥锁。\n         wrt.acquire();\n      mutex.release();\n   &#125;\t\n\n   public void releaseReadLock() &#123;\n      mutex.acquire();\n      --readerCount;\n      if (readerCount == 0) \t// Last reader\n         wrt.release();\n      mutex.release();\n   &#125;\n\n   public void acquireWriteLock() &#123;\n      wrt.acquire();\n   &#125;\n \n   public void releaseWriteLock() &#123;\n      wrt.release();\n   &#125;\n&#125;\n- **优先考虑作者**的解决方案：  - 第一个作者只需要等待正在读的读者读完就可以开始写，但只有在作者写完之后才能开始写。  - ```java    public class DataAccessPolicyManager2 &#123;        private int readCount, writeCount;        private Semaphore mutexReadCount, mutexWriteCount;        private Semaphore wrt, rdr;            public void acquireReadLock() &#123;            rdr.acquire();            mutexReadCount.acquire();            readCount = readCount + 1;            if (readCount == 1)                wrt.acquire();            mutexReadCount.release();            rdr.release();        &#125;            public void releaseReadLock() &#123;            mutexReadCount.acquire();            readCount = readCount - 1;            if (readCount == 0)                wrt.release();            mutexReadCount.release();        &#125;            public void acquireWriteLock() &#123;            mutexWriteCount.acquire();            writeCount = writeCount + 1;            if (writeCount == 1)                rdr.acquire();            mutexWriteCount.release();            wrt.acquire();        &#125;            public void releaseWriteLock() &#123;            mutexWriteCount.acquire();            writeCount = writeCount - 1;            if (writeCount == 0)                rdr.release();            mutexWriteCount.release();            wrt.release();        &#125;    &#125;\n\n\n\n\n\n10. Deadlock\nA set of processes is in a deadlock state when every process in the set is waiting on an event that can be caused only by another process in the set. （一个线程需要等待另一个线程时可能会发生死锁）\n\nFour Necessary Conditions for Deadlock \n\nMutual Exclusion : At least one resource must be held in a non-shareable mode.（至少有一个资源是非共享的）\nHold and Wait : A process must have at least one resource and be waiting for more. （一个进程在获得资源之后还要继续获得其他资源）\nNo Preemption : Resources cannot be preempted. Resources are not released until process does so voluntarily.（非抢占式）\nCircular Wait : P0 waits for P1, P1 waits for P2 ….. and finally Pn waits for P0.（循环等待）\n\n\n避免死锁：\n\nEnsure System never enters deadlock\nDeadlock Prevention ensures at least one of the necessary conditions do not hold by generally constraining in some way how requests for resources are made.（避免达成死锁必要条件）\nDeadlock Avoidance techniques supply the system with additional information about process resource needs over the lifetime of the process. （请求额外信息）\n\n\n\n\nAllow system to enter deadlock and then recover\n\nBanker’s Algorithm\n\n方法：存在一个序列，使得Pi的（Max - Allocation）的值始终小于（Available + Σ （Allocation of Pj））的值，其中j &lt; i.\n\n\n\n11. Memory\nExternal Fragmentation : the process cannot fit in our largest partition, we cannot run it. （内存空间不足）\n\nInternal Fragmentation : processes will not need all the space of the partitions allocated to them.（内存空间浪费）\n\n内存中存储的内容：\n\nText – Code of the program occupies this area and is generally static.（代码，文本，都是静态的）\nStack – A stack is generally a fixed sized region of memory which a process uses to create stack frames for holding parameters and local variables and return linkage addresses when calling functions. Frames are always added to and removed from the top of the stack in a LIFO manner which makes allocation and deallocation faster. Each thread must have its own stack but shares a heap.（内存空间中的栈保存进程的变量和函数调用，每个线程都有自己的栈）\nHeap – A heap is a variable sized region of memory which is used for creating dynamic data structures and objects. Variables created on the heap will still exist after function calls return, unlike stack based variables. Management of the heap’s linear space is more complex and takes longer. （堆保存数据结构和对象）\n\n\nBitmap：可以将数据缩小八倍空间，分配快速，取消分配也快速\n\nLinked List：（Dynamic）动态大小，没有内存浪费（Internal Fragmentation）\n\n分页机制（Page Mechanism）\n\n简介：将多个内存碎片组合为一个页面，在寻址过程中额外提供页的索引。\n优点：克服了之前内存分配的外部碎片问题（External Fragmentation），即内存分配过程中会出现多个小的空闲内存区间而没有较大的内存空间。而且保证了内存的安全，即不会寻址到内存空间外。\n缺点：需要额外的硬件支持。而且分页表可能会很大，在分页表的寻值速度变慢导致效率降低。\n\n\n\n12. File System\nDirectory File:\n\nThe file system requires a data structure to store this and other information relating to each file that is stored on a particular storage device. This data structure is called a file system directory.（文件系统目录）\n\n\n大需求：\n\nThe file system designer must decide how these blocks are allocated and deallocated in order to achieve the maximum performance from the file system as well as ensuring file persistence and data integrity. At the device driver level, the designer will have to be aware of the physical device characteristics.（如何分配和再分配磁盘区域使效率最大化，以及如何保证文件的持久性和数据完整性）\nThe file system user is concerned with how to access files, how to organise the internal structure of a file, organise collections of files into logical groupings and how to share them with other users. （如何使用户管理文件）\nOpen，Close，Copy，Create，Rename，Get attributes，Set attributes\n\n\n\n\n小需求：\n\nMapping files onto devices \n\nOrganizing files into directories \n\nFile Protection, File Sharing \n\nData Integrity &amp; Persistence\n\nSupport for a variety of storage devices\n\nUser Interface\n\n\n\nLinked Allocation\n\n简介：为了解决文件大小动态变化所带来空间不足的问题，采用在一个文件的每一个片段块的最后加上下一个片段块的指针，最后一个片段块中加入终止代码。\n\n\nIndexed Allocation\n\nindex block：前一种分配如果出现片段损坏将影响整个文件，可以将所有指针信息全部放入索引块的方法避免。\n\n\nManaging a Hierarchical File System Name Space\n\nA directory is a special file containing information about a subset of the file name space and is interpreted and manipulated by file system software.（目录是特殊的文件，包括其子文件的信息，由操作系统定义和操作）\n\n\n\n"},{"title":"汇编语言","url":"/2023/05/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","content":"第一章 基础知识\n计算机将代码和数据都储存在内存中，如果不加以区分，则两者都为二进制形式，没有任何区别。\n对于储存器和内存来说，1个字节（Byte）为一个存储单元，即一个8位二进制数 &#x3D; 两个十六进制数\nCPU对储存器的一次读写分为：\n储存单元的地址（地址信息）\n器件的选择，读或写的命令（控制信息）\n读或写的数据（数据信息）\n\n\n对于地址信息：\n总线数量 &#x3D; 总线宽度\n2 ^ N Byte 为该类型CPU的寻址能力，N为CPU地址总线数量\n解释：因为1个Byte为一个存储单元，所以只需算出地址所能表达出多少个不同二进制数即可\n\n\n\n\n主板上的RAM（如内存），ROM（如BIOS），显卡和网卡等均需要由CPU处理，并分配不同的内存地址空间。一个CPU的内存地址空间是有限的。\n\n\n第二章 寄存器\n8086CPU具有14种16位寄存器（AX，BX，CX，DX，CS，DS，SS，ES，SI，DI，SP，BP，IP，PSW），其中，AX、BX、CX和DX为通用寄存器，每个通用寄存器都可以拆分为两个8位通用寄存器使用。如AX可以拆分为AH，AL两个寄存器使用。\n\n注意：如果在代码中将通用寄存器拆分为两个寄存器使用，则这两个寄存器在如进位运算或数据存储上将没有任何关系。例子：\nmov al, FFH ; 将最大1字节数赋给aladd al, 2H  ; al加2，此时进位不会给ah，而会被CPU吃掉（这样描述很不规范）\n\n\n在寄存器或内存中，可以用字节（Byte）和字（word）两种数据格式存储，前提是储存空间足够大。\n\n在8086CPU中，物理地址（内存的真实地址）为20位二进制数，但在CPU中只有16位的总线，因此需要用段地址和偏移地址两个16位二进制数表示物理地址。\n\n物理地址 &#x3D; 段地址 × 16 + 偏移地址， 即段地址二进制数左移4位加上偏移地址\n\n地址计算在CPU中的地址加法器中进行\n\n段的概念：\n\n内存本质上并没有分段，只是CPU将内存以分段的形式使用\n\n一个段的最开始单元的物理地址的16进制数总是以0结尾\n\n一个段所能包含的最大容量为64KB，即偏移地址 L(0000H ~ FFFFH) &#x3D; 2 ^ 16 B &#x3D; 2 ^ 6 KB &#x3D; 64 KB\n\n\n\n段寄存器\n\n段寄存器有CS，DS，SS，ES四种，用来储存对应数据的段地址\nCS为代码段寄存器，储存代码数据在内存中的段地址。IP为指令地址寄存器，储存代码数据在内存中的偏移地址\n使用CS：IP的形式来表示（CS × 16 + IP）的物理地址\n[偏移地址] 表示DS × 16 + 偏移地址内存上的数据，其中数据可以为字也可以为字节（根据寄存器大小赋值，如mov ax，[0]则为将偏移地址为0处的字赋给ax）\n在内存中，字需要两个存储单元来存储，存储时低位在前，高位在后，以低位所在地址为其字的物理地址\n注意：不能将一个数字赋值给段寄存器（如mov ds，0001H），需要使用其他寄存器中转（如mov ax，0001H   mov ds，ax）\n\n\n栈\n\n由栈段寄存器SS和寄存器SP（SS：SP）表示栈顶的物理地址\n\n当栈为空时，SS：SP指向栈的下一位（如图中例子则为1010H）\n栈存储时从内存空间的最后一位开始存储，存储字时先将高位入栈，再将地位入栈\npush和pop指令可以对物理地址上的数进行直接处理\n\n\n\n第三章 常用的指令与技巧\n\n\n指令\n格式\n含义\n例子\n备注\n\n\n\nmov\nmov 寄存器，值\n将值赋给该寄存器\nmov ax, 0\n*也可以是[偏移地址]（默认指DS：偏移地址）\n\n\n\nmov 寄存器，寄存器\n将寄存器或存储单元的值赋给寄存器\nmov ax,bx\n\n\n\n\nmov 段寄存器，寄存器\n将寄存器的值赋给段寄存器\nmov ds,ax\n*不能给段寄存器直接赋值\n\n\noffset\noffset 标签\n获得标签处的数据或代码的偏移地址\noffset str\n*既可以获取变量的偏移地址，也可以获取代码上标签的偏移地址\n\n\ncmp\ncmp 寄存器，寄存器\n将两者数值相减但不保存\ncmp ax,bx\n*前者＜后者则CF标志位为1\n\n\n\ncmp 寄存器，值\n\ncmp ax,3\n\n\n\ndb\n变量名 db 值\n声明一个字节的空间存放数据\nvar1 db 10H\n*声明字符串时会占用连续若干个字节的空间\n\n\ndw\n变量名 dw 值\n声明一个字的空间\nvar2 dw 1000H\n\n\n\nadd\nadd 寄存器，值\n将值与寄存器中的值相加，将结果保存在寄存器中\nadd ax,1H\n*不处理进位，进位会携带CF标志\n\n\nadc\nadc 寄存器，值\n将值、CF的值与寄存器中的值相加\nadc ax,1H\n*会多与CF相加\n\n\nsub\nsub 寄存器，值\n与add差不多，但相减\n\n*会借位\n\n\ninc&#x2F;dev\ninc 寄存器\n自加1减1\ninc ax\n\n\n\nmul\nmul 寄存器，寄存器\n相乘，结果保存在前一个寄存器中\nmul ax,bx\n*8位乘8位结果为16位；16位乘16位结果为32位\n\n\ndiv\ndiv 值\nax为16位，则ax与该值相除，商保存在ax中，余数保存在dx中\ndiv 10\n*16位除8位结果为8位\n\n\nand\nand 寄存器，寄存器\n按位取和\nand ax,bx\n\n\n\nor\n…\n按位取或\n…\n\n\n\nxor\n…\n按位取异或\n…\n\n\n\nshl&#x2F;shr\nshl 寄存器,值\n将寄存器中值的二进制形式左（右）移若干位\nshl ax,1\n*最后一位&#x2F;第一位补0\n\n\nsal&#x2F;sar\n…\n…\n…\n*最后一位&#x2F;第一位保持原值\n\n\nrol&#x2F;ror\n…\n…\n…\n*将第一位的值赋给最后一位和CF位，反之亦然\n\n\nrcl&#x2F;rcr\n…\n…\n…\n*将第一位的值赋给CF位，同时CF位的值赋给最后一位，反之亦然\n\n\nloop\nloop 标签\n循环执行标签与loop之间的代码n次，n为CX中的值\nstart:          loop start\n\n\n\njc\njc 标签\n当CF位不为0时跳转\njc stop\n*cmp ax,bx中ax＜bx时则jc跳转\n\n\nja\nja 标签\n当CF≠0，ZF≠0时跳转\nja stop\n*实质为前者大于后者时跳转\n\n\nlea\nlea SI,标签\n从标签处读取字符串到SI指向的内存\nlea SI,str\n\n\n\nmovsb\nmovsb\n将地址SI处的字符串拷贝到地址DI处字符串的后面，并将结果保存在*地址DI处\nmovsb\n*将DS:SI处的字符串拷贝到ES:DI处字符串\n\n\n\nREP movsb\n循环拷贝直到DX &#x3D; 0\nREP movsb\n\n\n\ncmpsb\nREPE cmpsb\n当每个字符相等时循环\n\n*还是比较DS:SI和ES:DI处的字符串\n\n\n\nRENE cmpsb\n当每个字符不相等时循环\n\n*比较完成后可以使用je或jne跳转\n\n\n\n\n\n\n\n\n\n第四章 特殊数据类型的运算\n浮点数在计算机中的表示方法：\n\n一个单精度浮点数（float）占用32位&#x2F;4字节的空间\n一个单精度浮点数分三部分：符号（sign），指数（exponent），有效数字（significand）\n例子：178.625D：\n整数部分：178D &#x3D; 10110010B，小数部分：0.625D &#x3D; 0.101B\n178.625D &#x3D; 10110010.101B &#x3D; 1.0110010101 × 2 ^ 7\n将数字 × 2 ^ 127，则为1.0110010101 × 2 ^ 134\n将小数部分和指数部分取出并计算指数部分的二进制形式134D &#x3D; 10000110B\n按照 符号，指数，有效数字的顺序组合。即0,10000110,01100101010000000000000\n其中符号占1位，指数占8位，有效数字占23位\n\n\n\n\n\n\nFINIT ; Set FPU to default stateFLDCW cntrl ; Round even, Mask InterruptsFLD A ; Push A onto FP stackFMUL ST,ST(1) ; Multiply STST result on STFMUL ST,ST(1) ; Multiply STST result on ST again to get A^3FLD B ; Push B onto FP stackFSQRT ; Square root number on stack (B)FADD ST,ST(1) ; ADD top two numbers on stack (A^3 + √B)FSTSW stat ; Load FPU status into [stat]mov ax,stat ; Copy [stat] into axand al,0BFh ; Check all 6 status bitsjnz pass ; If any bit set then jumpFSTP RESULT ; Copy result from stack into RESULT\n\n字符串操作\n\n直接看例子：\nassume ds:datasegassume cs:codesegdataseg segment\tstr1 db &#x27;This is a test$&#x27;\tstr2 db &#x27;this string is a placeholder bulabula$&#x27;dataseg endscodeseg segment\tmov ax, ds\t\t\t\t\t; DS = ES\tmov es, ax\tLEA SI,str1\tLEA DI,str2\t\tmov cx, 15\tREP movsb\t\t\t\t\t; 重复复制字符串直到CX=0\t\tmov dx, offset str2\tmov ah, 09h\t\t\t\t\t; 将字符串内容输出到控制台上直到$\tint 021hcodeseg ends#输出：This is a test\n\n\n\n"}]